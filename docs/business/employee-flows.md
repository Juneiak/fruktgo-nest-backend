# Сквозные процессы для сотрудников (Employee) (draft v0.1)

Документ описывает сквозные процессы (end-to-end флоу) со стороны **сотрудников магазинов** (employees): продавцы, упаковщики, курьеры, кладовщики, менеджеры смен.

Цель:

* зафиксировать, как сотрудники магазинов взаимодействуют с платформой в ежедневной работе,
* дать основу для проектирования доменов Employee, Tasks, Orders, Inventory, Shifts,
* использовать как вход для backend-архитектуры, UI (дашборды/боты) и автотестов.

---

## 1. Подключение сотрудника и авторизация

### 1.1. Приглашение сотрудника

1. Селлер/менеджер магазина создаёт сотрудника в панели (см. `seller-flows.md`).
2. Система создаёт сущность `Employee`.
3. Система генерирует приглашение:

   * ссылка/QR-код для входа в web/app,
   * или deep-link для авторизации через Telegram-бота.
4. Сотруднику передаётся это приглашение (офлайн/онлайн).

### 1.2. Первая авторизация сотрудника

1. Сотрудник открывает ссылку/бота.
2. Проходит короткую идентификацию:

   * подтверждение телефона,
   * привязка к Telegram-аккаунту,
   * установка PIN/кода доступа (опционально).
3. Система:

   * находит `Employee` по телефону/Telegram,
   * подтягивает список магазинов и ролей сотрудника.
4. При наличии нескольких магазинов/ролей сотрудник выбирает, где и в какой роли он работает сейчас (например, "Курьер, Магазин №3").

**Бекенд:**

* Модель `Employee` с полями `telegramId`, `phone` для авторизации.
* Авторизационный флоу через Telegram/phone.
* Модель текущего контекста сотрудника: активный `Shop`, активная роль.

---

## 2. Смены (Shifts)

### 2.1. Открытие смены

1. Сотрудник приходит на работу и в приложении/боте выбирает "Начать смену".
2. Выбирает магазин (если их несколько) и, при необходимости, роль (если у него несколько ролей).
3. Система создаёт сущность `Shift`:

   * сотрудник,
   * магазин,
   * время начала,
   * статус `active`.
4. В течение смены все задачи и действия сотрудника привязываются к этой `Shift`.

### 2.2. Закрытие смены

1. В конце рабочего дня сотрудник выбирает "Закончить смену".
2. Система:

   * проверяет наличие незавершённых критичных задач (например, незавершённая доставка),
   * при необходимости требует их закрыть или перепривязать.
3. После подтверждения смена переводится в статус `closed` с фиксацией времени окончания.

**Бекенд:**

* Модель `Shift` с инвариантами:

  * у одного сотрудника в рамках одного магазина не может быть двух активных смен одновременно.

---

## 3. Задачи (Tasks) для сотрудников

Сотрудники работают через сущность `Task`, привязанную к `Employee`, `Shop` и, часто, к `Order`.

Типы задач (базовый список):

* `picking` — сборка заказа,
* `packing` — упаковка,
* `delivery` — доставка клиенту,
* `stock_intake` — приём товара,
* `stock_write_off` — списание,
* `inventory` — инвентаризация,
* `other` — прочие операционные задачи.

Общие статусы задач:

* `new` — создана, не взята в работу,
* `assigned` — назначена на конкретного сотрудника,
* `in_progress` — в работе,
* `paused` — временная пауза (опционально),
* `completed` — выполнена,
* `canceled` — отменена.

**Бекенд:**

* Модель `Task` с типом, статусом, связями (Order, Shift и т.д.).

---

## 4. Флоу для сборки заказа (picking)

### 4.1. Получение задач на сборку

1. После того как заказ клиента переходит в состояние "Оплачен" и привязан к магазину, система создаёт задачу `Task` типа `picking`.
2. Задача может:

   * автоматически назначаться на конкретного сотрудника (по правилам),
   * или попадать в общий пул задач магазина.
3. Сотрудник в интерфейсе видит список доступных задач.

### 4.2. Начало сборки

1. Сотрудник выбирает задачу "Собрать заказ #N" и нажимает "Начать".
2. Статус задачи → `in_progress`,
   статус заказа (внутренний) → `picking`.
3. Интерфейс показывает список позиций заказа, возможно с ориентировкой по залу/складу (ряд/полка — позже).

### 4.3. Процесс сборки

1. Сотрудник по мере нахождения позиций:

   * подтверждает добавление позиции в собранный заказ (по SKU),
   * при наличии сканера — сканирует штрихкод.
2. Если товар недоступен:

   * отмечает позицию как "нет в наличии",
   * может предложить замену (если бизнес-логика это допускает),
   * при согласовании через поддержку/систему — позиция заменяется.
3. Остатки по собранным позициям резервируются/списываются (в зависимости от модели учёта).

### 4.4. Завершение сборки

1. После подтверждения всех возможных позиций сотрудник нажимает "Сборка завершена".
2. Статус задачи → `completed`.
3. Статус заказа:

   * `picked` / `ready_for_packing` / `ready_for_delivery` — в зависимости от конфигурации,
   * фиксируется фактический состав и итоговая сумма (с учётом недособранных/заменённых позиций).

---

## 5. Упаковка заказа (packing)

(В MVP можно объединить с `picking`, но бизнес-флоу выделяем.)

### 5.1. Получение задач на упаковку

1. После завершения сборки заказ переходит в зону упаковки.
2. Создаётся задача `Task` типа `packing`.
3. Упаковщик видит список заказов, готовых к упаковке.

### 5.2. Упаковка

1. Упаковщик проверяет комплектность заказа.
2. Упаковывает товары по стандартам магазина (пакеты, коробки, термоупаковка и т.п.).
3. Может указать особенности/комментарии (хрупко, тяжёлый пакет отдельно и т.п.).

### 5.3. Завершение упаковки

1. После упаковки задача `packing` переводится в `completed`.
2. Заказ получает статус `ready_for_delivery` или `ready_for_pickup`.

---

## 6. Доставка заказа (delivery)

### 6.1. Назначение заказа курьеру

1. Для заказов с доставкой создаются задачи `Task` типа `delivery`.
2. Менеджер/система:

   * назначает задачу на конкретного курьера,
   * или оставляет в общем списке, откуда курьер сам берёт задачи.
3. Курьер видит список доступных/назначенных доставок с указанием:

   * адреса,
   * телефона клиента,
   * ориентировочного времени,
   * суммы к оплате при наличном расчёте (если допускается).

### 6.2. Выполнение доставки

1. Курьер принимает задачу → статус `in_progress`.
2. По пути может отмечать промежуточные статусы (опционально):

   * "выехал",
   * "прибыл по адресу".
3. После вручения заказа клиенту:

   * отмечает заказ как доставленный,
   * при наличной оплате фиксирует факт получения денег.

### 6.3. Невручение заказа

1. Если клиент не выходит на связь или отказывается от заказа:

   * курьер отмечает проблему в интерфейсе (причина ненаступления доставки),
   * заказ уходит в статус "проблемный" / `delivery_failed`.
2. Дальнейшие действия (возврат на склад, повторная попытка) определяются политиками магазина/платформы.

**Бекенд:**

* Логика статусов `Task` и `Order` для доставки.

---

## 7. Операции со складом

### 7.1. Приём товара (stock_intake)

1. При поступлении поставки создаётся задача `stock_intake`.
2. Кладовщик/ответственный сотрудник:

   * принимает товар по накладной,
   * сверяет количество/качество,
   * вводит данные в систему (по SKU/штрихкодам).
3. Система увеличивает остатки, создаёт `StockMovement` (тип `intake`).

### 7.2. Списания (stock_write_off)

1. При выявлении порчи/просрочки/потерь создаётся задача `stock_write_off`.
2. Сотрудник:

   * фиксирует позиции и количество,
   * выбирает причину списания.
3. Система уменьшает остатки, создаёт `StockMovement` (тип `write_off`).

### 7.3. Инвентаризация (inventory)

1. На период инвентаризации создаётся задача `inventory`.
2. Сотрудники обходят склад/зал и фиксируют фактические остатки.
3. Система сравнивает с учётными, формирует расхождения.
4. По результатам создаются корректирующие `StockMovement`.

---

## 8. Работа с чеками и кассой (оффлайн взаимодействие)

*(Может быть реализовано позже, но флоу выделяем сразу.)*

1. При выдаче/доставке заказа сотрудник может быть ответственен за пробитие чека на кассе.
2. Возможные варианты:

   * касса интегрирована с системой: чек создаётся автоматически,
   * касса работает автономно: сотрудник вручную пробивает чек и при необходимости фиксирует данные в системе.
3. Система:

   * хранит идентификатор фискального чека (если интеграция есть),
   * позволяет связать `Order` с записью о чеке.

---

## 9. Коммуникация и поддержка

### 9.1. Внутренние сообщения

1. Сотрудник может получать сообщения/уведомления:

   * от менеджера магазина,
   * от платформы (важные новости, обновления регламентов).
2. Каналы: внутри приложения/бота, Telegram-уведомления.

### 9.2. Обращения в поддержку

1. Сотрудник может создавать обращения в поддержку платформы:

   * технические проблемы с приложением/ботом,
   * вопросы по заказам/статусам.
2. Система создаёт `SupportCase` с типом "employee", привязанным к `Employee` и при необходимости к `Order`.

---

## 10. KPI и показатели сотрудников

1. Для каждого `Employee` система может считать базовые метрики:

   * количество выполненных задач (по типам),
   * среднее время выполнения задач (пicking/delivery),
   * долю задач с проблемами (например, доставок с пометкой `delivery_failed`).
2. Эти данные используются селлером/менеджером для оценки эффективности, мотивации и обучения.

**Бекенд:**

* Агрегирующие запросы/коллекции по `Task`, `Shift`, `Order`.

---

## 11. Ограничения и инварианты для Employee-флоу

1. У одного сотрудника не может быть более одной активной смены в одном магазине.
2. Задача может быть только в одном статусе и назначена не более чем на одного активного исполнителя (кроме задач-пула, если такие предусмотрены).
3. Любая операция, влияющая на заказ/склад/финансы, должна быть связана с:

   * конкретным `Employee`,
   * `Shop`,
   * (опционально) `Shift`.

Этот документ — v0.1. В следующих итерациях можно:

* детализировать state machine для задач и смен,
* описать роли по типам сотрудников (кассир, кладовщик, курьер) на уровне прав,
* добавить сценарии для работы в условиях высокой нагрузки (пики заказов).
